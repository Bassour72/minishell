âœ… Steps to Catch Child Exit:
Call fork()

Creates a child process.

In the child (pid == 0)

Do the work, then call exit(status).

In the parent

Use waitpid(child_pid, &status, 0) to wait for the child to finish.

Analyze status using macros:

WIFEXITED(status) â€” true if child exited normally.

WEXITSTATUS(status) â€” gives the exit code.

WIFSIGNALED(status) â€” true if child was terminated by a signal.

WTERMSIG(status) â€” gives the terminating signal number.

ðŸ§  Example Behavior
Macro	Purpose
WIFEXITED(s)	Child exited via exit() or return
WEXITSTATUS(s)	Gets exit code (if WIFEXITED is true)
WIFSIGNALED(s)	Child was killed by signal
WTERMSIG(s)	Which signal caused termination 

1. Limit your max number of processes (to prevent freezing your system): 

ulimit -u 50


git checkout main
git pull origin main


git merge execution
git push origin main


git checkout execution
git fetch origin
git rebase origin/main
# Fix conflicts if any, then
git checkout main
git merge execution
git push origin main

/////////////////////////////////
minishell$ ..
execve: Permission denied
minishell(96272,0x10adb3dc0) malloc: *** error for object 0x7ff39ec05890: pointer being freed was not allocated
minishell(96272,0x10adb3dc0) malloc: *** set a breakpoint in malloc_error_break to debug
minishell$ 

minishell: minishell: command not found
minishell$ export PATH+=:.
zsh: segmentation fault  ./minishell
ybassour@e3r10p1 minishell % 
int	wait_child_status( pid_t pid, t_env **env_list)
{
	int status;
	int sig;

	if (pid > 0)
		waitpid(pid, &status, 0);
	if (WIFEXITED(status)) //true if child exited normally.
	{
		sig = WEXITSTATUS(status); // â€” gives the exit code. // Gets exit code (if WIFEXITED is true)
		return (sig);
	}
	if (WIFSIGNALED(status)) // true if child was terminated by a signal.
	{
		 sig = WTERMSIG(status); // Which signal caused termination
		return (sig + 128);
	}
	return (1);
}