âœ… Steps to Catch Child Exit:
Call fork()

Creates a child process.

In the child (pid == 0)

Do the work, then call exit(status).

In the parent

Use waitpid(child_pid, &status, 0) to wait for the child to finish.

Analyze status using macros:

WIFEXITED(status) â€” true if child exited normally.

WEXITSTATUS(status) â€” gives the exit code.

WIFSIGNALED(status) â€” true if child was terminated by a signal.

WTERMSIG(status) â€” gives the terminating signal number.

ðŸ§  Example Behavior
Macro	Purpose
WIFEXITED(s)	Child exited via exit() or return
WEXITSTATUS(s)	Gets exit code (if WIFEXITED is true)
WIFSIGNALED(s)	Child was killed by signal
WTERMSIG(s)	Which signal caused termination 

1. Limit your max number of processes (to prevent freezing your system): 

ulimit -u 50


git checkout main
git pull origin main


git merge execution
git push origin main


git checkout execution
git fetch origin
git rebase origin/main
# Fix conflicts if any, then
git checkout main
git merge execution
git push origin main

/////////////////////////////////
minishell$ ..
execve: Permission denied
minishell(96272,0x10adb3dc0) malloc: *** error for object 0x7ff39ec05890: pointer being freed was not allocated
minishell(96272,0x10adb3dc0) malloc: *** set a breakpoint in malloc_error_break to debug
minishell$ 

minishell: minishell: command not found
minishell$ export PATH+=:.
zsh: segmentation fault  ./minishell
ybassour@e3r10p1 minishell % 
int	wait_child_status( pid_t pid, t_env **env_list)
{
	int status;
	int sig;

	if (pid > 0)
		waitpid(pid, &status, 0);
	if (WIFEXITED(status)) //true if child exited normally.
	{
		sig = WEXITSTATUS(status); // â€” gives the exit code. // Gets exit code (if WIFEXITED is true)
		return (sig);
	}
	if (WIFSIGNALED(status)) // true if child was terminated by a signal.
	{
		 sig = WTERMSIG(status); // Which signal caused termination
		return (sig + 128);
	}
	return (1);
}

minishell$ ''$$
AddressSanitizer:DEADLYSIGNAL
=================================================================
==23901==ERROR: AddressSanitizer: SEGV on unknown address 0x000000000000 (pc 0x000109e61a00 bp 0x7ffee5e6d3a0 sp 0x7ffee5e6cb40 T0)
==23901==The signal is caused by a READ memory access.
==23901==Hint: address points to the zero page.
    #0 0x109e61a00 in wrap_strcmp+0x50 (libclang_rt.asan_osx_dynamic.dylib:x86_64h+0x1aa00)
    #1 0x109dba62b in is_builtin execute_builtin.c:17
    #2 0x109dbbd3f in exec_block_command tree_exe_.c:24
    #3 0x109dbba0b in exec_tree tree_exe_.c:60
    #4 0x109db96d0 in execution execution.c:38
    #5 0x109d95f1f in shell_loop minishell.c:38
    #6 0x109d95b05 in main minishell.c:63
    #7 0x7fff6dc34cc8 in start+0x0 (libdyld.dylib:x86_64+0x1acc8)

==23901==Register values:
rax = 0x000000010ab50a40  rbx = 0x0000000000000000  rcx = 0x0000602000003290  rdx = 0x00001c0400000652  
rdi = 0x0000000000000000  rsi = 0x0000000109dcb180  rbp = 0x00007ffee5e6d3a0  rsp = 0x00007ffee5e6cb40  
 r8 = 0x0000000000000008   r9 = 0x0000000000000000  r10 = 0x0000000116d65420  r11 = 0x0000000109e619b0  
r12 = 0x0000000000000000  r13 = 0x0000000000000000  r14 = 0x0000000109dcb180  r15 = 0x0000000000000000  
AddressSanitizer can not provide additional info.
SUMMARY: AddressSanitizer: SEGV (libclang_rt.asan_osx_dynamic.dylib:x86_64h+0x1aa00) in wrap_strcmp+0x50
==23901==ABORTING
zsh: abort      ./minishell
